{
  "metadata": {
    "created_at": "2026-01-19T19:06:42Z",
    "purpose": "Verified evidence pack for CRT system mechanisms",
    "total_evidence_items": 15,
    "workspace": "d:\\AI_round2"
  },
  "evidence": [
    {
      "id": "E001",
      "file": "personal_agent/crt_memory.py",
      "start_line": 34,
      "end_line": 55,
      "excerpt": "@dataclass\nclass MemoryItem:\n    \"\"\"\n    A single memory item in CRT.\n    \n    Stores:\n    - Semantic vector (meaning signature)\n    - Trust score (evolves over time)\n    - Confidence score (fixed at creation)\n    - Source (user/system/fallback/etc)\n    - SSE mode (L/C/H)\n    - Metadata\n    \"\"\"\n    memory_id: str\n    vector: np.ndarray         # Semantic encoding\n    text: str                  # Original text (if SSE-L) or summary (if SSE-C/H)\n    timestamp: float           # Unix timestamp\n    confidence: float          # [0,1] How certain at creation\n    trust: float               # [0,1] How validated over time\n    source: MemorySource       # Where it came from\n    sse_mode: SSEMode          # Compression mode",
      "mechanism": "trust_confidence_schema",
      "purpose": "Memory items store trust and confidence as separate scalars that evolve differently"
    },
    {
      "id": "E002",
      "file": "personal_agent/crt_core.py",
      "start_line": 170,
      "end_line": 177,
      "excerpt": "    def belief_weight(self, trust: float, confidence: float) -> float:\n        \"\"\"\n        Combined belief weight (trust + confidence).\n        \n        w_i = α·τ_i + (1-α)·c_i\n        \"\"\"\n        alpha = self.config.alpha_trust\n        return alpha * trust + (1 - alpha) * confidence",
      "mechanism": "belief_weight_calculation",
      "purpose": "Belief weight combines trust (70%) and confidence (30%) for retrieval scoring"
    },
    {
      "id": "E003",
      "file": "personal_agent/crt_core.py",
      "start_line": 179,
      "end_line": 191,
      "excerpt": "    def retrieval_score(\n        self,\n        similarity: float,\n        recency: float,\n        belief: float\n    ) -> float:\n        \"\"\"\n        Final retrieval score.\n        \n        R_i = s_i · ρ_i · w_i\n        \"\"\"\n        return similarity * recency * belief",
      "mechanism": "retrieval_scoring_function",
      "purpose": "Retrieval score R_i multiplies similarity, recency weight, and belief weight"
    },
    {
      "id": "E004",
      "file": "personal_agent/crt_memory.py",
      "start_line": 271,
      "end_line": 291,
      "excerpt": "    def retrieve_memories(\n        self,\n        query: str,\n        k: int = 5,\n        min_trust: float = 0.0,\n        exclude_deprecated: bool = True,\n        ledger = None\n    ) -> List[Tuple[MemoryItem, float]]:\n        \"\"\"\n        Retrieve memories using trust-weighted scoring.\n        \n        Scoring: R_i = s_i · ρ_i · w_i\n        where:\n        - s_i = similarity to query\n        - ρ_i = recency weight\n        - w_i = belief weight (α·trust + (1-α)·confidence)\n        \n        Args:\n            exclude_deprecated: If True, filter out memories that are old values from resolved contradictions\n            ledger: CRT ledger instance for checking resolved contradictions",
      "mechanism": "retrieval_implementation",
      "purpose": "Retrieval function implements trust-weighted scoring with SSE invariant enforcement"
    },
    {
      "id": "E005",
      "file": "personal_agent/crt_core.py",
      "start_line": 43,
      "end_line": 76,
      "excerpt": "@dataclass\nclass CRTConfig:\n    \"\"\"CRT system configuration parameters.\"\"\"\n    \n    # Trust evolution rates\n    eta_pos: float = 0.1          # Trust increase rate for aligned memories\n    eta_reinforce: float = 0.05   # Reinforcement rate for validated memories\n    eta_neg: float = 0.15         # Trust decrease rate for contradictions\n    \n    # Thresholds\n    theta_align: float = 0.15     # Drift threshold for alignment\n    theta_contra: float = 0.42    # Drift threshold for contradiction (raised to reduce false positives)\n    theta_min: float = 0.25       # Minimum drift for confidence-based contradiction\n    theta_drop: float = 0.30      # Confidence drop threshold\n    theta_fallback: float = 0.40  # Drift threshold for fallback contradictions\n    \n    # Reconstruction gates\n    theta_intent: float = 0.5     # Intent alignment gate (lowered from 0.7 to reduce gate failures)\n    theta_mem: float = 0.38       # Memory alignment gate (lowered from 0.45 to allow detailed explanatory responses)\n    \n    # Reflection triggers\n    theta_reflect: float = 0.5    # Volatility threshold for reflection\n    \n    # Retrieval\n    lambda_time: float = 86400.0  # Time constant (1 day in seconds)\n    alpha_trust: float = 0.7      # Trust weight in retrieval (vs confidence)\n    \n    # Trust bounds\n    tau_base: float = 0.7         # Base trust for new memories (FIX: raised to avoid uncertainty trigger)\n    tau_fallback_cap: float = 0.3 # Max trust for fallback speech\n    tau_train_min: float = 0.6    # Min trust for weight updates",
      "mechanism": "gate_thresholds",
      "purpose": "CRT configuration defines gate thresholds and trust evolution parameters"
    },
    {
      "id": "E006",
      "file": "personal_agent/crt_core.py",
      "start_line": 411,
      "end_line": 454,
      "excerpt": "    def check_reconstruction_gates_v2(\n        self,\n        intent_align: float,\n        memory_align: float,\n        response_type: str,\n        grounding_score: float = 1.0,\n        contradiction_severity: str = \"none\",\n    ) -> Tuple[bool, str]:\n        \"\"\"\n        Gradient gates with response-type awareness (v2).\n        \n        Key improvements over v1:\n        1. Different thresholds for factual/explanatory/conversational\n        2. Grounding score (0-1) instead of binary check\n        3. Contradiction severity levels (blocking/note/none)\n        \n        Response types:\n        - factual: Strict gates for factual claims (What is my X?)\n        - explanatory: Relaxed gates for synthesis/explanation (How/Why questions)\n        - conversational: Minimal gates for chat/acknowledgment\n        \n        Args:\n            intent_align: Intent alignment score (0-1)\n            memory_align: Memory alignment score (0-1)\n            response_type: \"factual\" | \"explanatory\" | \"conversational\"\n            grounding_score: How well grounded in memory (0-1)\n            contradiction_severity: \"blocking\" | \"note\" | \"none\"\n        \n        Returns:\n            (passed, reason)\n        \"\"\"\n        # Blocking contradictions always fail\n        if contradiction_severity == \"blocking\":\n            return False, \"contradiction_fail\"\n        \n        # Response-type specific thresholds\n        if response_type == \"factual\":\n            # Factual gates - lowered thresholds for short fact extraction\n            if intent_align < 0.35:\n                return False, f\"factual_intent_fail (align={intent_align:.3f} < 0.35)\"\n            if memory_align < 0.35:\n                return False, f\"factual_memory_fail (align={memory_align:.3f} < 0.35)\"\n            # Only check grounding if answer is long (>50 chars)\n            # Short answers are likely direct fact extractions\n            # Lowered from 0.4 to 0.30 to reduce false rejections with ML classifier",
      "mechanism": "reconstruction_gate_implementation",
      "purpose": "Gradient gates v2 with response-type awareness and adaptive thresholds"
    },
    {
      "id": "E007",
      "file": "personal_agent/crt_ledger.py",
      "start_line": 36,
      "end_line": 78,
      "excerpt": "class ContradictionStatus:\n    \"\"\"Status of contradiction resolution.\"\"\"\n    OPEN = \"open\"              # Unresolved tension\n    REFLECTING = \"reflecting\"  # Reflection in progress\n    RESOLVED = \"resolved\"      # Merged via reflection\n    ACCEPTED = \"accepted\"      # Both kept as valid perspectives\n\n\nclass ContradictionType:\n    \"\"\"Type of contradiction based on fact topology.\"\"\"\n    REFINEMENT = \"refinement\"  # More specific information (Seattle → Bellevue)\n    REVISION = \"revision\"      # Explicit correction (\"actually\", \"I meant\", \"not X\")\n    TEMPORAL = \"temporal\"      # Time-based progression (Senior → Principal)\n    CONFLICT = \"conflict\"      # Mutually exclusive facts (Microsoft vs Amazon)\n\n\n@dataclass\nclass ContradictionEntry:\n    \"\"\"\n    A contradiction ledger entry.\n    \n    Records:\n    - Old memory (prior belief)\n    - New memory (contradicting belief)\n    - Drift measurements\n    - Resolution status\n    - Reflection metadata\n    \"\"\"\n    ledger_id: str\n    timestamp: float\n    old_memory_id: str\n    new_memory_id: str\n    \n    # Drift measurements\n    drift_mean: float           # Meaning drift\n    drift_reason: Optional[float] = None  # Reasoning drift (optional)\n    confidence_delta: float = 0.0\n    \n    # Status\n    status: str = ContradictionStatus.OPEN\n    contradiction_type: str = ContradictionType.CONFLICT  # Default to conflict\n    \n    # Slot tracking - which fact slots does this contradiction affect?\n    affects_slots: Optional[str] = None  # Comma-separated slot names (e.g., \"employer,location\")",
      "mechanism": "contradiction_ledger_schema",
      "purpose": "Contradiction ledger tracks drift measurements, status, and affected fact slots"
    },
    {
      "id": "E008",
      "file": "personal_agent/crt_ledger.py",
      "start_line": 497,
      "end_line": 503,
      "excerpt": "        # Calculate drift vector if embeddings provided\n        drift_vector = None\n        if old_vector is not None and new_vector is not None:\n            drift_vector = new_vector - old_vector",
      "mechanism": "drift_calculation",
      "purpose": "Drift vector calculated as difference between new and old memory embeddings"
    },
    {
      "id": "E009",
      "file": "personal_agent/crt_core.py",
      "start_line": 268,
      "end_line": 307,
      "excerpt": "    def evolve_trust_aligned(\n        self,\n        tau_current: float,\n        drift: float\n    ) -> float:\n        \"\"\"\n        Trust evolution for aligned memories (low drift).\n        \n        if D_mean ≤ θ_align:\n            τ_new = clip(τ_base + η_pos·(1 - D_mean), 0, 1)\n        \"\"\"\n        tau_new = tau_current + self.config.eta_pos * (1.0 - drift)\n        return np.clip(tau_new, 0.0, 1.0)\n    \n    def evolve_trust_reinforced(\n        self,\n        tau_current: float,\n        drift: float\n    ) -> float:\n        \"\"\"\n        Trust reinforcement for validated memories.\n        \n        τ_i = clip(τ_i + η_reinforce·(1 - D_mean), 0, 1)\n        \"\"\"\n        tau_new = tau_current + self.config.eta_reinforce * (1.0 - drift)\n        return np.clip(tau_new, 0.0, 1.0)\n    \n    def evolve_trust_contradicted(\n        self,\n        tau_current: float,\n        drift: float\n    ) -> float:\n        \"\"\"\n        Trust degradation for contradicted memories.\n        \n        τ_new = clip(τ_base · (1 - η_neg·D_mean), 0, 1)\n        \"\"\"\n        tau_new = tau_current * (1.0 - self.config.eta_neg * drift)\n        return np.clip(tau_new, 0.0, 1.0)",
      "mechanism": "trust_evolution_equations",
      "purpose": "Trust evolves via three paths: aligned (increase), reinforced (validate), contradicted (degrade)"
    },
    {
      "id": "E010",
      "file": "personal_agent/crt_core.py",
      "start_line": 27,
      "end_line": 41,
      "excerpt": "class SSEMode(Enum):\n    \"\"\"SSE compression modes based on significance.\"\"\"\n    LOSSLESS = \"L\"   # Identity-critical, contradiction-heavy\n    COGNI = \"C\"      # Fast sketch, \"what it felt like\"\n    HYBRID = \"H\"     # Adaptive mix\n\n\nclass MemorySource(Enum):\n    \"\"\"Source of memory item.\"\"\"\n    USER = \"user\"\n    SYSTEM = \"system\"\n    FALLBACK = \"fallback\"\n    EXTERNAL = \"external\"\n    REFLECTION = \"reflection\"",
      "mechanism": "memory_enums",
      "purpose": "SSEMode and MemorySource enums classify memory compression and origin"
    },
    {
      "id": "E011",
      "file": "personal_agent/crt_core.py",
      "start_line": 227,
      "end_line": 260,
      "excerpt": "    def compute_significance(\n        self,\n        emotion_intensity: float,\n        novelty: float,\n        user_marked: float,\n        contradiction_signal: float,\n        future_relevance: float\n    ) -> float:\n        \"\"\"\n        Compute significance score for SSE mode selection.\n        \n        S = w1·e + w2·n + w3·u + w4·k + w5·f\n        \"\"\"\n        cfg = self.config\n        return (\n            cfg.w_emotion * emotion_intensity +\n            cfg.w_novelty * novelty +\n            cfg.w_user_mark * user_marked +\n            cfg.w_contradiction * contradiction_signal +\n            cfg.w_future * future_relevance\n        )\n    \n    def select_sse_mode(self, significance: float) -> SSEMode:\n        \"\"\"\n        Select SSE compression mode based on significance.\n        \n        if S ≥ T_L  → SSE-L (lossless)\n        if S ≤ T_C  → SSE-C (cogni/sketch)\n        else        → SSE-H (hybrid)\n        \"\"\"\n        if significance >= self.config.T_L:\n            return SSEMode.LOSSLESS\n        elif significance <= self.config.T_C:\n            return SSEMode.COGNI",
      "mechanism": "sse_mode_selection",
      "purpose": "SSE mode selected based on significance score computed from 5 weighted factors"
    },
    {
      "id": "E012",
      "file": "personal_agent/active_learning.py",
      "start_line": 1,
      "end_line": 23,
      "excerpt": "\"\"\"\nActive Learning Coordinator for CRT\n\nMonitors gate decisions, collects corrections, triggers retraining,\nand hot-reloads improved models without system restart.\n\nThis is the \"self-improving\" magic - the system learns from every\nuser correction and automatically gets better over time.\n\nArchitecture:\n1. Gate Event Logger - Records every gate decision\n2. Correction Tracker - Captures user overrides/corrections\n3. Training Trigger - Decides when to retrain (data threshold)\n4. Model Trainer - Spawns background training job\n5. Hot Reloader - Swaps model without restart (thread-safe)\n6. Stats Reporter - Dashboard integration\n\nPhilosophy:\n- Never block user interactions (async training)\n- Conservative retraining (need enough data to improve)\n- Graceful degradation (if training fails, keep old model)\n- Auditable (every decision logged)\n\"\"\"",
      "mechanism": "active_learning_architecture",
      "purpose": "Active learning coordinator enables self-improvement through gate event logging and model retraining"
    },
    {
      "id": "E013",
      "file": "personal_agent/active_learning.py",
      "start_line": 38,
      "end_line": 63,
      "excerpt": "@dataclass\nclass GateEvent:\n    \"\"\"A single gate decision event.\"\"\"\n    event_id: str\n    timestamp: float\n    question: str\n    response_type_predicted: str  # From classifier\n    response_type_actual: Optional[str]  # From user correction\n    intent_align: float\n    memory_align: float\n    grounding_score: float\n    gates_passed: bool\n    gate_reason: str\n    user_override: Optional[bool]  # Did user correct us?\n    correction_timestamp: Optional[float]\n    thread_id: str\n    session_id: str\n    \n    def to_dict(self) -> Dict[str, Any]:\n        return asdict(self)\n\n\n@dataclass\n@dataclass\nclass LearningStats:\n    \"\"\"Current learning system statistics.\"\"\"",
      "mechanism": "gate_event_schema",
      "purpose": "GateEvent records all gate decision metadata for active learning training"
    },
    {
      "id": "E014",
      "file": "artifacts/adaptive_stress_report.20260119_190642.md",
      "start_line": 1,
      "end_line": 31,
      "excerpt": "# CRT Adaptive Stress Test Report\n\n**Run Date**: 2026-01-19 19:13:19 UTC\n**Thread ID**: adaptive_skeptical_001\n**JSONL Log**: adaptive_stress_run.20260119_190642.jsonl\n\n## Summary Statistics\n\n- **Total Turns**: 80\n- **Gated Turns**: 0\n- **Gate Pass Rate**: 100.0%\n- **Facts Introduced**: 9\n- **Facts Contradicted**: 9\n- **Contradictions Detected by System**: 0\n- **Truth Reintroduction Failures**: 0\n\n## Contradiction Ledger\n\n*No contradictions detected by system*\n\n## Truth Reintroduction Failures\n\n*No obvious truth reintroduction failures detected*\n\n## Top 5 Gate Failures\n\n*No gate failures*\n\n## Phase Breakdown\n\n- **Intro** (Turns 1-10): Fact introduction\n- **Contradiction** (Turns 11-25): Contradiction injection & detection\n- **Inventory** (Turns 26-40): Meta-queries & inventory honesty\n- **Adversarial** (Turns 41+): Advanced adversarial tests",
      "mechanism": "stress_test_results",
      "purpose": "Stress test reveals CRITICAL FAILURE: 9 contradictions injected, 0 detected by system"
    },
    {
      "id": "E015",
      "file": "personal_agent/crt_core.py",
      "start_line": 161,
      "end_line": 168,
      "excerpt": "    def recency_weight(self, t_memory: float, t_now: float) -> float:\n        \"\"\"\n        Recency weight for retrieval.\n        \n        ρ_i = exp(-(t_now - t_i) / λ)\n        \"\"\"\n        delta_t = t_now - t_memory\n        return math.exp(-delta_t / self.config.lambda_time)",
      "mechanism": "recency_weight_calculation",
      "purpose": "Recency weight decays exponentially with time constant λ = 86400s (1 day)"
    }
  ],
  "verification_notes": {
    "extraction_method": "Direct file reading with exact line numbers",
    "excerpt_integrity": "All excerpts are verbatim code, no paraphrasing or ellipsis",
    "coverage": [
      "trust_confidence_schema",
      "belief_weight_calculation",
      "retrieval_scoring_function",
      "retrieval_implementation",
      "gate_thresholds",
      "reconstruction_gate_implementation",
      "contradiction_ledger_schema",
      "drift_calculation",
      "trust_evolution_equations",
      "memory_enums",
      "sse_mode_selection",
      "active_learning_architecture",
      "gate_event_schema",
      "stress_test_results",
      "recency_weight_calculation"
    ],
    "critical_finding": "E014 reveals catastrophic contradiction detection failure - 0/9 contradictions detected in adaptive stress test"
  }
}
