{
  "evidence": [
    {
      "id": "E001",
      "file": "personal_agent/crt_memory.py",
      "start_line": 43,
      "end_line": 46,
      "excerpt": "    confidence: float          # [0,1] How certain at creation\n    trust: float               # [0,1] How validated over time\n    source: MemorySource       # Where it came from\n    sse_mode: SSEMode          # Compression mode",
      "mechanism": "trust_confidence_schema"
    },
    {
      "id": "E002",
      "file": "personal_agent/crt_core.py",
      "start_line": 183,
      "end_line": 195,
      "excerpt": "    def retrieval_score(\n        self,\n        similarity: float,\n        recency: float,\n        belief: float\n    ) -> float:\n        \"\"\"\n        Final retrieval score.\n        \n        R_i = s_i · ρ_i · w_i\n        \"\"\"\n        return similarity * recency * belief",
      "mechanism": "retrieval_scoring"
    },
    {
      "id": "E003",
      "file": "personal_agent/crt_core.py",
      "start_line": 46,
      "end_line": 52,
      "excerpt": "    # Reconstruction gates\n    theta_intent: float = 0.5     # Intent alignment gate (lowered from 0.7 to reduce gate failures)\n    theta_mem: float = 0.38       # Memory alignment gate (lowered from 0.45 to allow detailed explanatory responses)\n    \n    # Reflection triggers\n    theta_reflect: float = 0.5    # Volatility threshold for reflection",
      "mechanism": "gate_thresholds"
    },
    {
      "id": "E004",
      "file": "personal_agent/crt_core.py",
      "start_line": 265,
      "end_line": 280,
      "excerpt": "    def evolve_trust_aligned(\n        self,\n        tau_current: float,\n        drift: float\n    ) -> float:\n        \"\"\"\n        Trust evolution for aligned memories (low drift).\n        \n        if D_mean ≤ θ_align:\n            τ_new = clip(τ_base + η_pos·(1 - D_mean), 0, 1)\n        \"\"\"\n        tau_new = tau_current + self.config.eta_pos * (1.0 - drift)\n        return np.clip(tau_new, 0.0, 1.0)",
      "mechanism": "trust_evolution_equation"
    },
    {
      "id": "E005",
      "file": "personal_agent/crt_ledger.py",
      "start_line": 1,
      "end_line": 20,
      "excerpt": "\"\"\"\nCRT Contradiction Ledger - Preserves contradictions as first-class entities\n\nInstead of silently overwriting conflicting beliefs, CRT:\n1. Detects semantic drift between old and new memories\n2. Creates ledger entries linking conflicting memory pairs\n3. Tracks resolution status (open/resolved/accepted)\n4. Enables reflection on unresolved contradictions\n\nPhilosophy:\n- Contradictions are signals, not bugs\n- Preserve full history for auditing\n- Let reflection merge beliefs, not immediate overwrites\n- Trust evolves based on contradiction patterns\n\nKey difference from standard RAG:\n- Standard RAG: Last write wins, old data discarded\n- CRT Ledger: Both retained, conflict marked, resolution tracked\n\"\"\"",
      "mechanism": "contradiction_ledger_philosophy"
    },
    {
      "id": "E006",
      "file": "train_classifier.py",
      "start_line": 58,
      "end_line": 72,
      "excerpt": "    # Train TF-IDF vectorizer\n    print(f\"\\n⚙ Training TF-IDF vectorizer...\")\n    vectorizer = TfidfVectorizer(max_features=500, ngram_range=(1, 2))\n    X_train_vec = vectorizer.fit_transform(X_train)\n    X_test_vec = vectorizer.transform(X_test)\n    \n    # Train classifier\n    print(f\"⚙ Training Logistic Regression...\")\n    classifier = LogisticRegression(max_iter=1000, class_weight='balanced', random_state=42)\n    classifier.fit(X_train_vec, y_train)\n    \n    # Evaluate\n    y_pred = classifier.predict(X_test_vec)\n    accuracy = accuracy_score(y_test, y_pred)",
      "mechanism": "classifier_training_pipeline"
    },
    {
      "id": "E007",
      "file": "personal_agent/crt_core.py",
      "start_line": 170,
      "end_line": 180,
      "excerpt": "    def belief_weight(self, trust: float, confidence: float) -> float:\n        \"\"\"\n        Combined belief weight (trust + confidence).\n        \n        w_i = α·τ_i + (1-α)·c_i\n        \"\"\"\n        alpha = self.config.alpha_trust\n        return alpha * trust + (1 - alpha) * confidence",
      "mechanism": "belief_weight_calculation"
    },
    {
      "id": "E008",
      "file": "personal_agent/crt_core.py",
      "start_line": 27,
      "end_line": 33,
      "excerpt": "class MemorySource(Enum):\n    \"\"\"Source of memory item.\"\"\"\n    USER = \"user\"\n    SYSTEM = \"system\"\n    FALLBACK = \"fallback\"\n    EXTERNAL = \"external\"\n    REFLECTION = \"reflection\"",
      "mechanism": "memory_source_separation"
    },
    {
      "id": "E009",
      "file": "personal_agent/crt_core.py",
      "start_line": 238,
      "end_line": 250,
      "excerpt": "    def select_sse_mode(self, significance: float) -> SSEMode:\n        \"\"\"\n        Select SSE compression mode based on significance.\n        \n        if S ≥ T_L  → SSE-L (lossless)\n        if S ≤ T_C  → SSE-C (cogni/sketch)\n        else        → SSE-H (hybrid)\n        \"\"\"\n        if significance >= self.config.T_L:\n            return SSEMode.LOSSLESS\n        elif significance <= self.config.T_C:\n            return SSEMode.COGNI\n        else:\n            return SSEMode.HYBRID",
      "mechanism": "sse_mode_selection"
    },
    {
      "id": "E010",
      "file": "personal_agent/crt_core.py",
      "start_line": 142,
      "end_line": 150,
      "excerpt": "    def drift_meaning(self, z_new: np.ndarray, z_prior: np.ndarray) -> float:\n        \"\"\"\n        Meaning drift between new output and prior belief.\n        \n        D_mean = 1 - sim(z_new, z_prior)\n        \"\"\"\n        return 1.0 - self.similarity(z_new, z_prior)",
      "mechanism": "drift_calculation"
    },
    {
      "id": "E011",
      "file": "personal_agent/crt_rag.py",
      "start_line": 427,
      "end_line": 459,
      "excerpt": "        # Reconstruction constraint check\n        if not allow_fallback:\n            intent_align = float(result.get('intent_alignment', 0.0))\n            mem_align = float(result.get('memory_alignment', 0.0))\n            \n            gates_passed = True\n            gate_reason = None\n            \n            # Intent alignment gate\n            if intent_align < self.config.theta_intent:\n                gates_passed = False\n                gate_reason = f\"intent_alignment too low ({intent_align:.3f} < {self.config.theta_intent})\"\n            \n            # Memory alignment gate (for factual queries)\n            if response_type == 'factual' and mem_align < self.config.theta_mem:\n                gates_passed = False\n                gate_reason = f\"memory_alignment too low for factual query ({mem_align:.3f} < {self.config.theta_mem})\"\n            \n            # If gates fail, switch to uncertainty mode\n            if not gates_passed:\n                mode = 'uncertainty'\n                result['mode'] = mode\n                result['gates_passed'] = False\n                result['gate_reason'] = gate_reason\n                \n                # Don't store low-alignment outputs as high-trust beliefs\n                if mem_align < self.config.theta_mem:\n                    # Uncertainty response\n                    answer = self._generate_uncertainty_response(\n                        user_query,\n                        retrieved_memories,\n                        intent_align,\n                        mem_align\n                    )",
      "mechanism": "reconstruction_gate_implementation"
    },
    {
      "id": "E012",
      "file": "artifacts/crt_stress_report.20260119_133318.md",
      "start_line": 1,
      "end_line": 10,
      "excerpt": "# CRT Stress Test Report (20260119_133318)\n\n- Turns: 30\n- Gates: pass=25 fail=5\n- Contradictions detected: 6\n- Avg confidence: 0.823\n- Source JSONL: crt_stress_run.20260119_133318.jsonl\n\n## A/B Scoring (Learned vs Heuristic)",
      "mechanism": "stress_test_metrics"
    }
  ]
}
